\setchaptergraphic{
    \begin{tikzpicture}[
        shorten >=1pt,>={Stealth[round]},
        node distance=2.5 cm,
        every state/.style={draw=blue!50,very thick,fill=blue!20}
    ]
        \node[initial, state]   (A)                    {$q_0$};
        \node[state, accepting] (B) [right of=A]       {$q_1$};
        \node[state, accepting] (C) [above right of=B] {$q_2$};
        \node[state]            (R) [below right of=B] {$q_3$};

        \path[->] (A) edge [above]                  node [align=center] {0,1} (B)
                  (B) edge [above left, bend left]  node [align=center] {1} (C)
                      edge [below left]             node [align=center] {0} (R)
                  (C) edge [below right, bend left] node [align=center] {0,1} (B)
                  (R) edge [loop right]             node [align=center] {0,1} ();
    \end{tikzpicture}
}

\chapter{Computation Theory}
\label{ch:computation}

\section{Finite Automata}

\begin{defn}
    An \emph{alphabet} is a non-empty set whose elements are referred to as \emph{symbols}. \emph{Strings} (or \emph{words}) over a given alphabet are finite sequences of symbols from the alphabet. A \emph{language} is a set of strings over an alphabet.
\end{defn}

\begin{rmk}
    Alphabets and languages may be non-finite, but strings are generally considered to only include finite sequences. The empty string will be denoted by $\emptystring$.
\end{rmk}

\begin{defn}
    Let $\Sigma$ be an alphabet. Then the language consisting of all strings over $\Sigma$ of length $n$ is denoted by $\Sigma^{n}$. The \emph{Kleene closure} of $\Sigma$ is
    \begin{align*}
        \Sigma^{*} = \bigunion_{i\in\N}\Sigma^{i}.
    \end{align*}
\end{defn}

\begin{defn}
    A (determinstic) \emph{finite automata} is a $5$-tuple $(Q, \Sigma, \delta, q_0, F)$, where
    \begin{itemize}
        \item $Q$ is a finite set of \emph{states},
        \item $\Sigma$ is an alphabet,
        \item $\delta: Q \times \Sigma \to Q$ is the \emph{transition function},
        \item $q_0 \in Q$ is the \emph{start state},
        \item $F \subseteq Q$ are the \emph{accept states}.
    \end{itemize}
    An automata starts in state $q_0$, and is given an input consisting over a string over $\Sigma$. For each symbol $s$ in the input, the automata moves from state $q$ to state $\delta(q, s)$. Once the end of the input is reached, if the state $q$ of the automata is an accept state --- that is, $q \in F$, then the automata is said to have \emph{accepted} the input.
\end{defn}

\begin{defn}
    The \emph{language accepted by} a finite automata $M$ is a language $A$ consisting of all strings over $\Sigma$ that are accepted by the finite automata. We denote this by $L(M) = A$. A \emph{regular language} is any language accepted by some finite automata.
\end{defn}

\begin{rmk}
    Finite automata can be represented as a graph, where states are represented as nodes, and transitions are edges between states, labelled by the symbol that triggers the transition. When graphically representing a finite automata as a graph, accept states may be represented as double-circled nodes.
\end{rmk}

\begin{exmp}
    \begin{figure}[ht!]
        \centering
        \begin{tikzpicture}[
            shorten >=1pt,>={Stealth[round]},
            node distance=2 cm,
            every state/.style={draw=blue!50,very thick,fill=blue!20}
        ]
            \node[initial, state]   (S) {$q_0$};
            \node[state]            (0) [right of=S] {$q_1$};
            \node[state]            (00) [right of=0] {$q_2$};
            \node[state, accepting] (001) [right of=00] {$q_3$};
    
            \path[->] (S)   edge [above, bend left]     node [align=center] {0} (0)
                      (S)   edge [loop below]           node [align=center] {1} ()
                      (0)   edge [above, bend left]     node [align=center] {0} (00)
                            edge [above, bend left]     node [align=center] {1} (S)
                      (00)  edge [loop above]           node [align=center] {0} ()
                            edge [above, bend left]     node [align=center] {1} (001)
                      (001) edge [below, bend left]     node [align=center] {0} (0)
                            edge [above, bend right=60] node [align=center] {1} (S);
        \end{tikzpicture}
        \caption{Example finite automata}
        \label{fig:example-finite-automata}
    \end{figure}

    In the finite automata shown in Figure \ref{fig:example-finite-automata}, $Q = \left\{q_0, q_1, q_2, q_3\right\}$, $\Sigma = \left\{0, 1\right\}$, $F = \{q_3\}$, and $\delta$ is
    \begin{center}
        \begin{tabular}{|c||c|c|}
            \hline
            \thead{$\delta$} & \thead{$0$}    & \thead{$1$} \\
            \hline\hline
            \textsc{$q_0$}   & \textsc{$q_1$} & \textsc{$q_0$} \\
            \hline
            \textsc{$q_1$}   & \textsc{$q_2$} & \textsc{$q_0$} \\
            \hline
            \textsc{$q_2$}   & \textsc{$q_2$} & \textsc{$q_3$} \\
            \hline
            \textsc{$q_3$}   & \textsc{$q_1$} & \textsc{$q_0$} \\
            \hline
        \end{tabular}.
    \end{center}

    This language accepted by this finite automata is the set of all binary strings which end with \texttt{001}. We can use an inductive proof on the length of the longest input to prove this.
\end{exmp}

\begin{thm}\label{regular-language-union-intersection}
    Let $A$ and $B$ be regular languages, then $A \union B$ and $A \intersection B$ are also regular languages.
\end{thm}

\begin{proof}
    Let $\Sigma$ be the union of the alphabets of $A$ and $B$. Since $A$ and $B$ are regular, we know that there exists finite automata $M_A = \left(Q_1, \Sigma, \delta_1, s_1, F_1\right)$ and $M_B = \left(Q_2, \Sigma, \delta_2, s_2, F_2\right)$. Now we construct a new finite automata that runs $M_A$ and $M_B$ in parallel. To do this, consider the finite automata $M = \left(Q, \Sigma, \delta, s, F\right)$, where $Q = Q_1 \times Q_2$, $s = (s_1, s_2)$, and  $\delta: (Q_1 \times Q_2) \times \Sigma \to Q_1 \times Q_2$ is defined by $\delta\left((p_1, p_2), a\right) = \left(\delta_1\left(p_1, a\right), \delta_2\left(p_2, a\right)\right)$.
    
    If $F = F_1 \times F_2$, then $M$ accepts precisely the strings accepted by both $M_A$ and $M_B$ --- that is, $L(M) = A \intersection B$. If instead $F = \left(F_1 \times Q_2\right) \union \left(Q_1 \times F_2\right)$, then $M$ accepts the strings accepted by at least one of $M_A$ and $M_B$ --- that is, $L(M) = A \union B$.
\end{proof}

\begin{defn}
    A \emph{non-determinstic} finite automata is a $5$-tuple $(Q, \Sigma, \delta, q_0, F)$, where
    \begin{itemize}
        \item $Q$ is a finite set of \emph{states},
        \item $\Sigma$ is an alphabet,
        \item $\delta: Q \times \left(\Sigma \union \{\varepsilon\}\right) \to 2^{Q}$ is the \emph{transition function},
        \item $q_0 \in Q$ is the \emph{start state},
        \item $F \subseteq Q$ are the \emph{accept states}.
    \end{itemize}
    A non-determinstic finite automata $M$ accepts an input $w$ over $\Sigma$ when there exists $w'$ that causes $M$ to end in an accept state, where $w'$ is constructed by inserting any finite number of $\varepsilon$ into $w$.
\end{defn}

\begin{rmk}
    Standard determinstic finite automata may be referred to as DFAs, while non-determinstic finite automata may be referred to as NFAs.
\end{rmk}

\begin{rmk}
    A NFA can essentially be viewed as a DFA which can split into multiple parallel copies of itself.
\end{rmk}

\begin{defn}
    Given a transition function $\delta: Q \times \left(\Sigma \union \{\varepsilon\}\right) \to 2^{Q}$ and $R \subseteq Q$, the \emph{epsilon-closure} of $R$ is
    \begin{align*}
        E\left(R\right) = \left\{q \in Q \compbar \exists r \in R\left[\delta\left(r, \varepsilon\right) = q\right]\right\}.
    \end{align*}
\end{defn}

\begin{thm}\label{dfa-nfa-equivalence}
    Let $N$ be a non-determinstic finite automata, and $L$ be the language it accepts. Then $L$ is a regular language. Equivalently, there is an equivalent determinstic finite automata for every non-determinstic finite automata.
\end{thm}

\begin{proof}
    Let $V = \left(Q, \Sigma, \delta, q_0, F\right)$ be a non-determinstic finite automata. We will construct an equivalent determinstic finite automata $M$. Let $M = \left(Q', \Sigma, \delta', q_0', F'\right)$, where
    \begin{itemize}
        \item $Q' = 2^Q$,
        \item For all $R \in Q'$, define $\delta'(R, a) = E\left(\bigunion_{r \in R}\delta(r, a)\right)$,
        \item $q_0' = \left\{q_0\right\}$,
        \item $F' = \left\{R \in Q \compbar R \intersection F \neq \emptyset\right\}$.
    \end{itemize}
\end{proof}

\begin{defn}
    The \emph{regular operations} are union, intersection, complement, concatenation, and star, which the set of regular languages is closed under.
\end{defn}

\begin{defn}
    A \emph{regular expression} is a sequence of regular operations applied to regular languages. Formally, given an alphabet $\Sigma$, the following are regular expressions:
    \begin{itemize}
        \item $a$, for any $a \in \Sigma$,
        \item $\varepsilon$,
        \item $\emptyset$,
        \item $R_1 \union R_2$, where $R_1$ and $R_2$ are themselves regular expressions,
        \item $R_1 \cdot R_2$, where $R_1$ and $R_2$ are themselves regular expressions,
        \item $R_1^{\star}$, where $R_1$ is a regular expression,
    \end{itemize}
\end{defn}

\begin{defn}
    For a regular expression $R_1$, we also define $R_1^{+} = R_1R_1^{\star}$.
\end{defn}

\begin{exmp}
    The regular expression $1^{\star}(0\union 1^{+})^{\star}$ is the language of binary strings where every $0$ is followed by at least one $1$.
\end{exmp}

\section{Non-Regular Languages}

\begin{lemma}{Pumping Lemma}{\label{pumping-lemma}}\proofbreak
    Let $A$ be a regular language. There exists $p \in \N$, the \emph{pumping length}, such that if $s \in A$ has length at least $p$, then we can divide $s$ into three pieces $s = xyz$ satisfying
    \begin{itemize}
        \item $\abs{y} > 0$,
        \item $\abs{xy} \leq p$,
        \item $xy^{i}z \in A$ for all $i \geq 0$.
    \end{itemize}
\end{lemma}

\begin{proof}
    Let $M = (Q, \Sigma, \delta, q_s, F)$ be a determinstic finite automata recognizing $A$. Let $p = \abs{Q}$. Then for any $s = s_1s_2 \cdots s_n \in A$, where $n \geq p$, let $r_1, r_2, \ldots, r_n, r_{n+1}$ be the sequence of states that $M$ visits in input $s$. Since $n+1 \geq p + 1 > p$, by the pigeonhole principle \ref{pigeonhole}, it follows that at least one state must be visited twice within the first $p+1$ states --- that is, that there must be $i > j$ such that $r_i = r_j$ and $i \leq p + 1$.

    Then, take $x = s_1s_2 \cdots s_{i-1}$, $y = s_{i}s_{i+1} \cdots s_{j-1}$, and $z = s_{j}s_{j+1}\cdots s_n$. Notice that since $i > j$, $j-1 \geq i$, and so $\abs{y} > 0$. Furthermore, $\abs{xy} = j-1$ and since $j < i \leq p + 1$, it follows that $j-1 < i-1 \leq p$, and so $\abs{xy} \leq p$. Finally, since $r_{i}r_{i+1}\cdots r_{j}$ is a cycle that occurs on input $y$, we clearly have $xy^{i}z \in A$ for all $i \geq 0$.
\end{proof}

\begin{exmp}
    Consider the language $A = \{0^n1^n | n \geq 0\}$. Assume, for the sake of contradiction, that $A$ is regular and so by the pumping lemma \ref{pumping-lemma} there must exist a pumping length $p$. We consider $s = 0^{p}1^{p} \in A$, and by the pumping lemma are guaranteed $xyz = 0^{p}1^{p}$ since $\abs{s} = 2p \geq p$. In particular, we have $\abs{xy} \leq p$, and so $xy = 0^{t}$ for some $t \leq p$. It follows that $y = 0^{s}$ for some $0 < s \leq p$, and so by the pumping lemma we must have $xy^{i}z = 0^{p+(i-1)s}1^{p} \in A$. However, this is false by the definition of $A$ whenever $i \neq 1$, and so we have a contradiction. It follows that $A$ cannot be a regular language.
\end{exmp}

\begin{exmp}
    Consider the language $C$ consisting of all binary strings containing an equal number of $0$s and $1$s. Notice that $A = C \intersection 0^{*}1^{*}$ --- that is, $A$ is precisely the subset of $0^{*}1^{*}$ where the number of $0$s and $1$s are equal. If $C$ was regular, then $A$ would be regular since regular languages are closed under intersection. Therefore, $C$ cannot be a regular language.
\end{exmp}
